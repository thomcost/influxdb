package swaggervalidator

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"

	"github.com/getkin/kin-openapi/openapi3filter"
	"go.uber.org/zap"
)

type validatingMiddleware struct {
	router *openapi3filter.Router
	inner  http.Handler
}

var _ http.Handler = (*validatingMiddleware)(nil)

// NewMiddleware wraps inner with an http.Handler that will validate API requests and responses,
// and will print warnings to stdout.
//
// If the swagger definition can't be loaded for any reason,
// NewMiddleware will log a message to logger and will return inner.
func NewMiddleware(logger *zap.Logger, inner http.Handler, swaggerData []byte) http.Handler {
	// We're only using the logger to detail loading.
	// The error messages generated by the validator are whitespace heavy,
	// so we're just printf-ing them for now.
	logger = logger.With(zap.String("svc", "swagger_loader"))

	// loadSwagger has a different definition depending on whether using the 'assets' build tag.
	s := loadSwagger(logger, swaggerData)
	if s == nil {
		// Couldn't load the swagger, so we can't do validation.
		// loadSwagger should have handled logging anything necessary.
		return inner
	}

	router := openapi3filter.NewRouter().WithSwagger(s)
	return &validatingMiddleware{router: router, inner: inner}
}

func (m *validatingMiddleware) validateRequest(r *http.Request) (*openapi3filter.RequestValidationInput, error) {
	route, params, err := m.router.FindRoute(r.Method, r.URL)
	if err != nil {
		return nil, err
	}

	reqVI := &openapi3filter.RequestValidationInput{
		Request:    r,
		PathParams: params,
		Route:      route,
	}
	reqVI.GetQueryParams() // Set query params from request input.

	if err := openapi3filter.ValidateRequest(r.Context(), reqVI); err != nil {
		return reqVI, err
	}

	return reqVI, nil
}

func (m *validatingMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	reqVI, err := m.validateRequest(r)
	if err != nil {
		// Validation errors are formatted with a lot of whitespace, so just fmt.Printf this out for developers to read.
		fmt.Printf("SWAGGER REQUEST VALIDATION ERROR HANDLING [%s %s]: %s\n", r.Method, r.URL, err.Error())
	}

	t := newTeedResponseWriter(w)
	m.inner.ServeHTTP(t, r)

	if err := t.ValidateResponse(r.Context(), reqVI); err != nil {
		// Validation errors are formatted with a lot of whitespace, so just fmt.Printf this out for developers to read.
		fmt.Printf("SWAGGER RESPONSE VALIDATION ERROR HANDLING [%s %s]: %s\n", r.Method, r.URL, err.Error())
	}
}

type teedResponseWriter struct {
	w          http.ResponseWriter
	body       *bytes.Buffer
	statusCode int

	bodyWriter io.Writer
}

var _ http.ResponseWriter = (*teedResponseWriter)(nil)

func newTeedResponseWriter(w http.ResponseWriter) *teedResponseWriter {
	t := &teedResponseWriter{
		w: w,

		// Status code defaults to 200 until WriteHeader is called, according to Godoc for http.ResponseWriter.
		statusCode: 200,

		// Creating a new bytes.Buffer for every response is not ideal, but we can improve performance on that later.
		body: new(bytes.Buffer),
	}
	t.bodyWriter = io.MultiWriter(w, t.body)
	return t
}

func (t *teedResponseWriter) Write(p []byte) (int, error) {
	return t.bodyWriter.Write(p)
}

func (t *teedResponseWriter) Header() http.Header {
	return t.w.Header()
}

func (t *teedResponseWriter) WriteHeader(statusCode int) {
	t.w.WriteHeader(statusCode)
	t.statusCode = statusCode
}

func (t *teedResponseWriter) ValidateResponse(ctx context.Context, reqVI *openapi3filter.RequestValidationInput) error {
	respVI := &openapi3filter.ResponseValidationInput{
		RequestValidationInput: reqVI,

		Status: t.statusCode,
		Header: t.w.Header(),
		Body:   ioutil.NopCloser(t.body),

		Options: &openapi3filter.Options{
			IncludeResponseStatus: true,
		},
	}

	return openapi3filter.ValidateResponse(ctx, respVI)
}
